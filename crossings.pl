forall(P,Q) :- \+ (P, \+ Q).


app_select(X,List,Remainder) :-
  append(Front, [X|Back], List),
  append(Front, Back, Remainder).


% The following might be useful for testing.

write_list(List) :-
  forall(member(X, List),
         (write('  '), write(X), nl)
        ).


% solutions for testing 

solution([f+g,f,f+w,f+g,f+c,f,f+b,f,f+g]).
solution([f+g,f,f+c,f+g,f+w,f,f+b,f,f+g]).
solution([f+g,f,f+b,f,f+w,f+g,f+c,f,f+g]).
solution([f+g,f,f+b,f,f+c,f+g,f+w,f,f+g]).



% check if the given list of items are safe
% aborts computation when one case succeeds
% PRE:  input is valid state and ground
% POST: succeed if the list is save
safe(Bank) :-
  Bank = [],
  !.
safe([X|_]) :-
  X = f,
  !.
safe(Bank) :-
  \+((member(w, Bank), member(g, Bank))),
  \+((member(g, Bank), member(c, Bank))),
  !.


% checks if the given state is save
% PRE:  N and S are valid and ground
% POST: holds when both N and S are save fail otherwise
safe_state(N-S) :-
  safe(N),
  safe(S).


% checks if the two given states are equal
% does not take into consideration of the ordering within
% a gven bank
% PRE:  states are ground and valid
% POST: holds when both banks of each state are equal
%       fail othwerwise
equiv(X-Y, V-W) :-
  sort(X, A),
  sort(V, B),
  A == B,
  sort(Y, C),
  sort(W, D),
  C == D.


% checks if the given state represents the goal state
% PRE:  given state is ground and valid
% POST: holds when the given state is the goal fail otherwise
goal([]-[f|X]) :-
  length(X, 4),
  sort(X, G),
  G == [b, c, g, w].


% checks if the given state is an elem of the given list of
% states
% PRE:  given states and states in the given lists are ground
%       and valid
% POST: holds when given states is in the list fail otherwise
visited(_, []) :-
  fail.
visited(S, [H|T]) :-
  equiv(S, H);
  visited(S, T).


% this relation holds when given list can be formed by inserting
% some single element X into a list R
% PRE:  the list to be formed must be a valid list and ground
% POST: holds when there is any combination of elem X and list R
%       where the list to be formed is equal to the result of
%       inserting X into R, fails otherwise
select(_, [], _) :-
  fail.
select(X, [Y|L], R) :-
  (X = Y, L = R);
  ([Z|N] = R, Z = Y, select(X, L, N)).


% can be used to generate all possible valid move and corrosponding
% resulttant state from a given valid state
% though the second definiton of crossing may be defined in terms of
% the first one, ie by swaping the banks of the first argument during
% the input and output phase, this implementaton is slightly more
% efficient since there is no swaping needed
% PRE:  fst argument is ground nad valid state
% POST: holds when the state NEXT can be generated by applying the move
%       MOVE to the state given in the first argument, fails otherwise
crossing([f|X]-Y, Move, Next) :-
  (select(A, X, R), Move = f+A, Next = R-[f, A|Y]);
  (Move = f, Next = X-[f|Y]).
crossing(Y-[f|X], Move, Next) :-
  (select(A, X, R), Move = f+A, Next = [f, A|Y]-R);
  (Move = f, Next = [f|Y]-X).


% the first argument is the given state
% generate a sequence of move that leads from the given state to a state
% that satisfy the predicate goal defined ealier
% PRE:  the given states is safe, valid and ground
% POST: each move leads to a different safe, valid state
%       no loops in the Sequence of moves
%       the Sequence of moves leads to the goal state
journey(X, _, Sequence) :-
  goal(X),
  Sequence = [].
journey(X-Y, H, Sequence) :-
  crossing(X-Y, Move, Next),
  safe_state(Next),
  \+(visited(Next, H)),
  journey(Next, [Next|H], Tail),
  Sequence = [Move|Tail].


% can be used to find all Sequence of moves that leads from the state
% [f,w,g,c,b]-[] to the goal state, or to check if the given 
% sequence of move leads to the goal state from the state
% [f,w,g,c,b]-[]
% PRE:  NONE
% POST: binds Sequence a list of valid moves that leads to the goal
%       state, fails when there are no such moves 
succeeds(Sequence) :-
  journey([f,w,g,c,b]-[], [[f,w,g,c,b]-[]], Sequence).


% a tail recursive version of count_items/2
% counts the frequency of each item in the given list
% PRE:  2nd argument is ground and represnts the list of
%       frequencies collected so far
%       1st argument is ground and is a list
% POST: records the frequency of each item in the list
%       operatons are stable, the records appear in the
%       order defined in the list
count_items([], A, Stats) :-
  !,
  reverse(A, Stats, []).
count_items([H|T], A, Stats) :-
  count_dup([H|T], H, 0, [], N, R),
  !,
  count_items(R, [(H, N)|A], Stats).


% counts the frequency of each item in the given list
% delegate the task to count_items/3 a tail recursive
% version of count_items/2
% PRE:  given list is ground
% POST: records the frequency of each item in the list
%       operatons are stable, the records appear in the
%       order defined in the list
count_items(List, Stats) :-
  count_items(List, [], Stats).


% a helper predicate for count_dup and count_items/3
% reverses the fst argument and returns in the third
% argument
reverse([],Z,Z).
reverse([H|T],Z,A) :-
  reverse(T,Z,[H|A]).


% a tail recursive helper predicate for count_items/3
% the first argument is the given list to be counted
% given list must be ground
% the second argument is the given item to check
% given item must be ground
% counts the frequency of given item in given list, return in N
% removes all instances of given item from list, return remaining
% list in R
% order of remaining elems are preserved
count_dup([], _, AC, REV, N, R) :-
  !,
  N = AC,
  reverse(REV, R, []).
count_dup([X|T], X, AC, REV, N, R) :-
  UP is AC + 1,
  !,
  count_dup(T, X, UP, REV, N, R).
count_dup([H|T], X, AC, REV, N, R) :-
  \+(H = X),
  !,
  count_dup(T, X, AC, [H|REV], N, R).


% tail recursive helper predicate for g_journeys/2
% the first argument is the given list to be counted
% given list must be ground
% the second argument is the given item to check
% given item must be ground
% counts the frequency of given item occuring in given list
count([], _, AC, AC).
count([X|T], X, AC, R) :-
  UP is AC + 1,
  !,
  count(T, X, UP, R).
count([H|T], X, AC, R) :-
  \+(H = X),
  !,
  count(T, X, AC, R).


% can be used to generate the possible successful Sequence
% of moves that leads to the goal state, and the corrosponding
% number of goat transporting moves
% PRE:  N is either not ground or ground to a natural number
% POST: Seq represents a sequence of moves that leads to the goal
%       state
%       holds when N can be bind to th number of goat transporting
%       moves in Seq, fails otherwise
g_journeys(Seq,N) :-
  succeeds(Seq),
  count(Seq, f+g, 0, N).


%% END OF FILE
